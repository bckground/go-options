// Code generated by github.com/bckground/go-options. DO NOT EDIT.
// Source: config{}
//
// Generated by this command:
//
//	go-options -imports=time,net/url,time2=time -namespace=OptionNs -option=Option config
//

package test

import "fmt"

import (
	"net/url"
	"time"
	time2 "time"
)

import "github.com/google/go-cmp/cmp"

type ApplyOptionFunc func(c *config) error

func (f ApplyOptionFunc) apply(c *config) error {
	return f(c)
}

func newConfig(options ...Option) (config, error) {
	var c config
	err := applyConfigOptions(&c, options...)
	return c, err
}

func applyConfigOptions(c *config, options ...Option) error {
	c.myIntWithDefault = 1
	c.myFloatWithDefault = 1.23
	c.myStringWithDefault = `default string`
	c.myStructWithDefault.a = 1
	for _, o := range options {
		if err := o.apply(c); err != nil {
			return err
		}
	}
	return nil
}

type Option interface {
	apply(*config) error
}

type optionNamespace struct{}

var OptionNs optionNamespace

type optionMyIntImpl struct {
	o int
}

func (o optionMyIntImpl) apply(c *config) error {
	c.myInt = o.o
	return nil
}

func (o optionMyIntImpl) Equal(v optionMyIntImpl) bool {
	switch {
	case !cmp.Equal(o.o, v.o):
		return false
	}
	return true
}

func (o optionMyIntImpl) String() string {
	name := "MyInt"

	// hack to avoid go vet error about passing a function to Sprintf
	var value interface{} = o.o
	return fmt.Sprintf("%s: %+v", name, value)
}

func (optionNamespace) MyInt(o int) Option {
	return optionMyIntImpl{
		o: o,
	}
}

type optionMyIntWithDefaultImpl struct {
	o int
}

func (o optionMyIntWithDefaultImpl) apply(c *config) error {
	c.myIntWithDefault = o.o
	return nil
}

func (o optionMyIntWithDefaultImpl) Equal(v optionMyIntWithDefaultImpl) bool {
	switch {
	case !cmp.Equal(o.o, v.o):
		return false
	}
	return true
}

func (o optionMyIntWithDefaultImpl) String() string {
	name := "MyIntWithDefault"

	// hack to avoid go vet error about passing a function to Sprintf
	var value interface{} = o.o
	return fmt.Sprintf("%s: %+v", name, value)
}

func (optionNamespace) MyIntWithDefault(o int) Option {
	return optionMyIntWithDefaultImpl{
		o: o,
	}
}

type optionYourIntImpl struct {
	o int
}

func (o optionYourIntImpl) apply(c *config) error {
	c.myRenamedInt = o.o
	return nil
}

func (o optionYourIntImpl) Equal(v optionYourIntImpl) bool {
	switch {
	case !cmp.Equal(o.o, v.o):
		return false
	}
	return true
}

func (o optionYourIntImpl) String() string {
	name := "YourInt"

	// hack to avoid go vet error about passing a function to Sprintf
	var value interface{} = o.o
	return fmt.Sprintf("%s: %+v", name, value)
}

func (optionNamespace) YourInt(o int) Option {
	return optionYourIntImpl{
		o: o,
	}
}

type optionMyDocumentedIntImpl struct {
	o int
}

func (o optionMyDocumentedIntImpl) apply(c *config) error {
	c.myDocumentedInt = o.o
	return nil
}

func (o optionMyDocumentedIntImpl) Equal(v optionMyDocumentedIntImpl) bool {
	switch {
	case !cmp.Equal(o.o, v.o):
		return false
	}
	return true
}

func (o optionMyDocumentedIntImpl) String() string {
	name := "MyDocumentedInt"

	// hack to avoid go vet error about passing a function to Sprintf
	var value interface{} = o.o
	return fmt.Sprintf("%s: %+v", name, value)
}

/*MyDocumentedInt does something
 */
func (optionNamespace) MyDocumentedInt(o int) Option {
	return optionMyDocumentedIntImpl{
		o: o,
	}
}

type optionMyCommentedIntImpl struct {
	o int
}

func (o optionMyCommentedIntImpl) apply(c *config) error {
	c.myCommentedInt = o.o
	return nil
}

func (o optionMyCommentedIntImpl) Equal(v optionMyCommentedIntImpl) bool {
	switch {
	case !cmp.Equal(o.o, v.o):
		return false
	}
	return true
}

func (o optionMyCommentedIntImpl) String() string {
	name := "MyCommentedInt"

	// hack to avoid go vet error about passing a function to Sprintf
	var value interface{} = o.o
	return fmt.Sprintf("%s: %+v", name, value)
}

/*MyCommentedInt for some reason
 */
func (optionNamespace) MyCommentedInt(o int) Option {
	return optionMyCommentedIntImpl{
		o: o,
	}
}

type optionMyDocAndCommentIntImpl struct {
	o int
}

func (o optionMyDocAndCommentIntImpl) apply(c *config) error {
	c.myDocAndCommentInt = o.o
	return nil
}

func (o optionMyDocAndCommentIntImpl) Equal(v optionMyDocAndCommentIntImpl) bool {
	switch {
	case !cmp.Equal(o.o, v.o):
		return false
	}
	return true
}

func (o optionMyDocAndCommentIntImpl) String() string {
	name := "MyDocAndCommentInt"

	// hack to avoid go vet error about passing a function to Sprintf
	var value interface{} = o.o
	return fmt.Sprintf("%s: %+v", name, value)
}

/*
MyDocAndCommentInt does something else
for some other reason
*/
func (optionNamespace) MyDocAndCommentInt(o int) Option {
	return optionMyDocAndCommentIntImpl{
		o: o,
	}
}

type optionMyFloatImpl struct {
	o float64
}

func (o optionMyFloatImpl) apply(c *config) error {
	c.myFloat = o.o
	return nil
}

func (o optionMyFloatImpl) Equal(v optionMyFloatImpl) bool {
	switch {
	case !cmp.Equal(o.o, v.o):
		return false
	}
	return true
}

func (o optionMyFloatImpl) String() string {
	name := "MyFloat"

	// hack to avoid go vet error about passing a function to Sprintf
	var value interface{} = o.o
	return fmt.Sprintf("%s: %+v", name, value)
}

/*
MyFloat takes a float
really a float
*/
func (optionNamespace) MyFloat(o float64) Option {
	return optionMyFloatImpl{
		o: o,
	}
}

type optionMyFloatWithDefaultImpl struct {
	o float64
}

func (o optionMyFloatWithDefaultImpl) apply(c *config) error {
	c.myFloatWithDefault = o.o
	return nil
}

func (o optionMyFloatWithDefaultImpl) Equal(v optionMyFloatWithDefaultImpl) bool {
	switch {
	case !cmp.Equal(o.o, v.o):
		return false
	}
	return true
}

func (o optionMyFloatWithDefaultImpl) String() string {
	name := "MyFloatWithDefault"

	// hack to avoid go vet error about passing a function to Sprintf
	var value interface{} = o.o
	return fmt.Sprintf("%s: %+v", name, value)
}

func (optionNamespace) MyFloatWithDefault(o float64) Option {
	return optionMyFloatWithDefaultImpl{
		o: o,
	}
}

type optionMyStringImpl struct {
	o string
}

func (o optionMyStringImpl) apply(c *config) error {
	c.myString = o.o
	return nil
}

func (o optionMyStringImpl) Equal(v optionMyStringImpl) bool {
	switch {
	case !cmp.Equal(o.o, v.o):
		return false
	}
	return true
}

func (o optionMyStringImpl) String() string {
	name := "MyString"

	// hack to avoid go vet error about passing a function to Sprintf
	var value interface{} = o.o
	return fmt.Sprintf("%s: %+v", name, value)
}

func (optionNamespace) MyString(o string) Option {
	return optionMyStringImpl{
		o: o,
	}
}

type optionMyStringWithDefaultImpl struct {
	o string
}

func (o optionMyStringWithDefaultImpl) apply(c *config) error {
	c.myStringWithDefault = o.o
	return nil
}

func (o optionMyStringWithDefaultImpl) Equal(v optionMyStringWithDefaultImpl) bool {
	switch {
	case !cmp.Equal(o.o, v.o):
		return false
	}
	return true
}

func (o optionMyStringWithDefaultImpl) String() string {
	name := "MyStringWithDefault"

	// hack to avoid go vet error about passing a function to Sprintf
	var value interface{} = o.o
	return fmt.Sprintf("%s: %+v", name, value)
}

func (optionNamespace) MyStringWithDefault(o string) Option {
	return optionMyStringWithDefaultImpl{
		o: o,
	}
}

type optionMyFuncImpl struct {
	o func() int
}

func (o optionMyFuncImpl) apply(c *config) error {
	c.myFunc = o.o
	return nil
}

func (o optionMyFuncImpl) Equal(v optionMyFuncImpl) bool {
	switch {
	case !cmp.Equal(o.o, v.o):
		return false
	}
	return true
}

func (o optionMyFuncImpl) String() string {
	name := "MyFunc"

	// hack to avoid go vet error about passing a function to Sprintf
	var value interface{} = o.o
	return fmt.Sprintf("%s: %+v", name, value)
}

func (optionNamespace) MyFunc(o func() int) Option {
	return optionMyFuncImpl{
		o: o,
	}
}

type optionMyIntPointerImpl struct {
	o *int
}

func (o optionMyIntPointerImpl) apply(c *config) error {
	c.myIntPointer = o.o
	return nil
}

func (o optionMyIntPointerImpl) Equal(v optionMyIntPointerImpl) bool {
	switch {
	case !cmp.Equal(o.o, v.o):
		return false
	}
	return true
}

func (o optionMyIntPointerImpl) String() string {
	name := "MyIntPointer"

	// hack to avoid go vet error about passing a function to Sprintf
	var value interface{} = o.o
	return fmt.Sprintf("%s: %+v", name, value)
}

func (optionNamespace) MyIntPointer(o *int) Option {
	return optionMyIntPointerImpl{
		o: o,
	}
}

type optionMyInterfaceImpl struct {
	o interface{}
}

func (o optionMyInterfaceImpl) apply(c *config) error {
	c.myInterface = o.o
	return nil
}

func (o optionMyInterfaceImpl) Equal(v optionMyInterfaceImpl) bool {
	switch {
	case !cmp.Equal(o.o, v.o):
		return false
	}
	return true
}

func (o optionMyInterfaceImpl) String() string {
	name := "MyInterface"

	// hack to avoid go vet error about passing a function to Sprintf
	var value interface{} = o.o
	return fmt.Sprintf("%s: %+v", name, value)
}

func (optionNamespace) MyInterface(o interface{}) Option {
	return optionMyInterfaceImpl{
		o: o,
	}
}

type optionMyURLImpl struct {
	o url.URL
}

func (o optionMyURLImpl) apply(c *config) error {
	c.myURL = o.o
	return nil
}

func (o optionMyURLImpl) Equal(v optionMyURLImpl) bool {
	switch {
	case !cmp.Equal(o.o, v.o):
		return false
	}
	return true
}

func (o optionMyURLImpl) String() string {
	name := "MyURL"

	// hack to avoid go vet error about passing a function to Sprintf
	var value interface{} = o.o
	return fmt.Sprintf("%s: %+v", name, value)
}

/*MyURL types requiring imports
 */
func (optionNamespace) MyURL(o url.URL) Option {
	return optionMyURLImpl{
		o: o,
	}
}

type optionMyDurationImpl struct {
	o time.Duration
}

func (o optionMyDurationImpl) apply(c *config) error {
	c.myDuration = o.o
	return nil
}

func (o optionMyDurationImpl) Equal(v optionMyDurationImpl) bool {
	switch {
	case !cmp.Equal(o.o, v.o):
		return false
	}
	return true
}

func (o optionMyDurationImpl) String() string {
	name := "MyDuration"

	// hack to avoid go vet error about passing a function to Sprintf
	var value interface{} = o.o
	return fmt.Sprintf("%s: %+v", name, value)
}

func (optionNamespace) MyDuration(o time.Duration) Option {
	return optionMyDurationImpl{
		o: o,
	}
}

type optionMyDuration2Impl struct {
	o time2.Duration
}

func (o optionMyDuration2Impl) apply(c *config) error {
	c.myDuration2 = o.o
	return nil
}

func (o optionMyDuration2Impl) Equal(v optionMyDuration2Impl) bool {
	switch {
	case !cmp.Equal(o.o, v.o):
		return false
	}
	return true
}

func (o optionMyDuration2Impl) String() string {
	name := "MyDuration2"

	// hack to avoid go vet error about passing a function to Sprintf
	var value interface{} = o.o
	return fmt.Sprintf("%s: %+v", name, value)
}

func (optionNamespace) MyDuration2(o time2.Duration) Option {
	return optionMyDuration2Impl{
		o: o,
	}
}

type optionMyStructImpl struct {
	a int
	b int
}

func (o optionMyStructImpl) apply(c *config) error {
	c.myStruct.a = o.a
	c.myStruct.b = o.b
	return nil
}

func (o optionMyStructImpl) Equal(v optionMyStructImpl) bool {
	switch {
	case !cmp.Equal(o.a, v.a):
		return false
	case !cmp.Equal(o.b, v.b):
		return false
	}
	return true
}

func (o optionMyStructImpl) String() string {
	name := "MyStruct"

	type stripped optionMyStructImpl
	value := stripped(o)
	return fmt.Sprintf("%s: %+v", name, value)
}

func (optionNamespace) MyStruct(a int, b int) Option {
	return optionMyStructImpl{
		a: a,
		b: b,
	}
}

type optionMyStructWithDefaultImpl struct {
	a int
}

func (o optionMyStructWithDefaultImpl) apply(c *config) error {
	c.myStructWithDefault.a = o.a
	return nil
}

func (o optionMyStructWithDefaultImpl) Equal(v optionMyStructWithDefaultImpl) bool {
	switch {
	case !cmp.Equal(o.a, v.a):
		return false
	}
	return true
}

func (o optionMyStructWithDefaultImpl) String() string {
	name := "MyStructWithDefault"

	type stripped optionMyStructWithDefaultImpl
	value := stripped(o)
	return fmt.Sprintf("%s: %+v", name, value)
}

func (optionNamespace) MyStructWithDefault(a int) Option {
	return optionMyStructWithDefaultImpl{
		a: a,
	}
}

type optionMyPointerToStructImpl struct {
	a int
	b int
}

func (o optionMyPointerToStructImpl) apply(c *config) error {
	c.myPointerToStruct = new(struct{ a, b int })
	c.myPointerToStruct.a = o.a
	c.myPointerToStruct.b = o.b
	return nil
}

func (o optionMyPointerToStructImpl) Equal(v optionMyPointerToStructImpl) bool {
	switch {
	case !cmp.Equal(o.a, v.a):
		return false
	case !cmp.Equal(o.b, v.b):
		return false
	}
	return true
}

func (o optionMyPointerToStructImpl) String() string {
	name := "MyPointerToStruct"

	type stripped optionMyPointerToStructImpl
	value := stripped(o)
	return fmt.Sprintf("%s: %+v", name, value)
}

func (optionNamespace) MyPointerToStruct(a int, b int) Option {
	return optionMyPointerToStructImpl{
		a: a,
		b: b,
	}
}

type optionMyStructWithVariadicSliceImpl struct {
	a int
	b []int
}

func (o optionMyStructWithVariadicSliceImpl) apply(c *config) error {
	c.myStructWithVariadicSlice.a = o.a
	c.myStructWithVariadicSlice.b = o.b
	return nil
}

func (o optionMyStructWithVariadicSliceImpl) Equal(v optionMyStructWithVariadicSliceImpl) bool {
	switch {
	case !cmp.Equal(o.a, v.a):
		return false
	case !cmp.Equal(o.b, v.b):
		return false
	}
	return true
}

func (o optionMyStructWithVariadicSliceImpl) String() string {
	name := "MyStructWithVariadicSlice"

	type stripped optionMyStructWithVariadicSliceImpl
	value := stripped(o)
	return fmt.Sprintf("%s: %+v", name, value)
}

func (optionNamespace) MyStructWithVariadicSlice(a int, b ...int) Option {
	return optionMyStructWithVariadicSliceImpl{
		a: a,
		b: b,
	}
}

type optionMySliceImpl struct {
	o []int
}

func (o optionMySliceImpl) apply(c *config) error {
	c.mySlice = o.o
	return nil
}

func (o optionMySliceImpl) Equal(v optionMySliceImpl) bool {
	switch {
	case !cmp.Equal(o.o, v.o):
		return false
	}
	return true
}

func (o optionMySliceImpl) String() string {
	name := "MySlice"

	// hack to avoid go vet error about passing a function to Sprintf
	var value interface{} = o.o
	return fmt.Sprintf("%s: %+v", name, value)
}

func (optionNamespace) MySlice(o ...int) Option {
	return optionMySliceImpl{
		o: o,
	}
}

type optionMyPointerToSliceImpl struct {
	o []int
}

func (o optionMyPointerToSliceImpl) apply(c *config) error {
	c.myPointerToSlice = &o.o
	return nil
}

func (o optionMyPointerToSliceImpl) Equal(v optionMyPointerToSliceImpl) bool {
	switch {
	case !cmp.Equal(o.o, v.o):
		return false
	}
	return true
}

func (o optionMyPointerToSliceImpl) String() string {
	name := "MyPointerToSlice"

	// hack to avoid go vet error about passing a function to Sprintf
	var value interface{} = o.o
	return fmt.Sprintf("%s: %+v", name, value)
}

func (optionNamespace) MyPointerToSlice(o ...int) Option {
	return optionMyPointerToSliceImpl{
		o: o,
	}
}

type optionYourSliceImpl struct {
	o []int
}

func (o optionYourSliceImpl) apply(c *config) error {
	c.myRenamedSlice = o.o
	return nil
}

func (o optionYourSliceImpl) Equal(v optionYourSliceImpl) bool {
	switch {
	case !cmp.Equal(o.o, v.o):
		return false
	}
	return true
}

func (o optionYourSliceImpl) String() string {
	name := "YourSlice"

	// hack to avoid go vet error about passing a function to Sprintf
	var value interface{} = o.o
	return fmt.Sprintf("%s: %+v", name, value)
}

func (optionNamespace) YourSlice(o ...int) Option {
	return optionYourSliceImpl{
		o: o,
	}
}

type optionMyPointerToIntImpl struct {
	o int
}

func (o optionMyPointerToIntImpl) apply(c *config) error {
	c.myPointerToInt = &o.o
	return nil
}

func (o optionMyPointerToIntImpl) Equal(v optionMyPointerToIntImpl) bool {
	switch {
	case !cmp.Equal(o.o, v.o):
		return false
	}
	return true
}

func (o optionMyPointerToIntImpl) String() string {
	name := "MyPointerToInt"

	// hack to avoid go vet error about passing a function to Sprintf
	var value interface{} = o.o
	return fmt.Sprintf("%s: %+v", name, value)
}

func (optionNamespace) MyPointerToInt(o int) Option {
	return optionMyPointerToIntImpl{
		o: o,
	}
}

type optionYourIntWithPointerImpl struct {
	o int
}

func (o optionYourIntWithPointerImpl) apply(c *config) error {
	c.myPointerToRenamedInt = &o.o
	return nil
}

func (o optionYourIntWithPointerImpl) Equal(v optionYourIntWithPointerImpl) bool {
	switch {
	case !cmp.Equal(o.o, v.o):
		return false
	}
	return true
}

func (o optionYourIntWithPointerImpl) String() string {
	name := "YourIntWithPointer"

	// hack to avoid go vet error about passing a function to Sprintf
	var value interface{} = o.o
	return fmt.Sprintf("%s: %+v", name, value)
}

func (optionNamespace) YourIntWithPointer(o int) Option {
	return optionYourIntWithPointerImpl{
		o: o,
	}
}

type optionWithJsonTagButNoOptionsImpl struct {
	o string
}

func (o optionWithJsonTagButNoOptionsImpl) apply(c *config) error {
	c.WithJsonTagButNoOptions = o.o
	return nil
}

func (o optionWithJsonTagButNoOptionsImpl) Equal(v optionWithJsonTagButNoOptionsImpl) bool {
	switch {
	case !cmp.Equal(o.o, v.o):
		return false
	}
	return true
}

func (o optionWithJsonTagButNoOptionsImpl) String() string {
	name := "WithJsonTagButNoOptions"

	// hack to avoid go vet error about passing a function to Sprintf
	var value interface{} = o.o
	return fmt.Sprintf("%s: %+v", name, value)
}

/*WithJsonTagButNoOptions ensure we can handle multiple tags
 */
func (optionNamespace) WithJsonTagButNoOptions(o string) Option {
	return optionWithJsonTagButNoOptionsImpl{
		o: o,
	}
}

type optionGotBothImpl struct {
	o string
}

func (o optionGotBothImpl) apply(c *config) error {
	c.WithBothJsonAndOptions = o.o
	return nil
}

func (o optionGotBothImpl) Equal(v optionGotBothImpl) bool {
	switch {
	case !cmp.Equal(o.o, v.o):
		return false
	}
	return true
}

func (o optionGotBothImpl) String() string {
	name := "GotBoth"

	// hack to avoid go vet error about passing a function to Sprintf
	var value interface{} = o.o
	return fmt.Sprintf("%s: %+v", name, value)
}

func (optionNamespace) GotBoth(o string) Option {
	return optionGotBothImpl{
		o: o,
	}
}
